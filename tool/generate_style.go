package main

import (
	"bytes"
	"go/format"
	"html/template"
	"os"
	"strings"

	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

const tmpl = `// Code generated by tool/generate_style.go; DO NOT EDIT.
package textstyle
const ({{range .}}
    {{.Label}}_LOWER_OFFSET = {{printf "%d" .LowerOffset}}
    {{.Label}}_UPPER_OFFSET = {{printf "%d" .UpperOffset}}
    {{.Label}}_DIGIT_OFFSET = {{printf "%d" .DigitOffset}}{{end}}
)
{{range .}}
func {{.TitleLabel}}() *Transformer{
    return NewTransformer(
        NewSimpleReplacer(
            {{.Label}}_LOWER_OFFSET,
            {{.Label}}_UPPER_OFFSET,
            {{.Label}}_DIGIT_OFFSET,
        ),
    )
}
{{end}}`

type Style struct {
	Label       string
	TitleLabel  string
	LowerOffset rune
	UpperOffset rune
	DigitOffset rune
}

// replacePattern must be aA0 with a specific text style.
func NewStyle(label string, replacePattern string) Style {
	ss := make([]rune, 3)
	var n int
	for _, r := range replacePattern {
		if n > 2 {
			panic("argument `replace` must be each text style's aA0")
		}
		ss[n] = r
		n++
	}
	if n != 3 {
		panic("argument `replace` must be each text style's aA0")
	}
	// for generate title case
	c := cases.Title(language.English)
	s := Style{
		strings.ToUpper(label),
		c.String(label),
		ss[0] - 'a',
		ss[1] - 'A',
		ss[2] - '0',
	}
	return s
}

func main() {
	styles := []Style{
		NewStyle("bold", "ğšğ€ğŸ"),
		NewStyle("italic", "ğ‘ğ´0"),
	}
	t := template.Must(template.New("style").Parse(tmpl))
	f, err := os.Create("../styles.go")
	if err != nil {
		panic(err)
	}
	defer f.Close()

	buf := new(bytes.Buffer)
	if err := t.Execute(buf, styles); err != nil {
		panic(err)
	}
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		panic(err)
	}
	_, err = f.Write(formatted)
	if err != nil {
		panic(err)
	}
}
